@page "/Login"

@using CoyoteFrontend.Data
@using CoyoteNETCore.Shared.RequestInput;
@using CoyoteNETCore.Shared.ResultHandling;
@using CoyoteNETCore.Shared.Auth;
@using CoyoteNETCore.Shared.Extensions;

@inject Service _service


<link rel="stylesheet" href="/css/login.min.css">

<div id="loginform">
    <label id="errormessage">@string.Join(Environment.NewLine, Errors)</label>
    <b id="info">Sign in!</b>
    <input id="username_input" type="text" placeholder="Username..." @bind="Username" />

    <input id="password_input" type="password" placeholder="Password..." @bind="Password" />
    <a href="#" id="forgot_password">Forgot Password</a>
    <a href="Register" id="create_account">Create Account</a>
    <button id="signin_button" @onclick="TryLogin">Sign in!</button>
</div>

@code {
    public string Username { get; set; }
    public string Password { get; set; }
    public List<string> Errors { get; set; } = new List<string>();

    async Task TryLogin()
    {
        Errors.Clear();
        var result = VerifyReuqest();

        if (!result.IsSucceeded)
        {
            Errors = result.Error.ErrorMessages.ToList();
            return;
        }

        var response = await _service.TryPOST<LoginInput, JsonWebToken>(new LoginInput(Username, Password), "/Account/Login/");

        if (!response.IsSucceeded)
        {
            Errors.AddRange(response.Error.ErrorMessages);
        }
        else
        {
            FakeLocalStorage.Token = response.Value.Token;
            FakeLocalStorage.ExpiresAt = response.Value.Expires.FromUnixTime();
            FakeLocalStorage.Username = response.Value.Username;
            Errors.Add("Successfully logged in");
        }

        this.StateHasChanged();
    }

    Result<bool> VerifyReuqest()
    {
        var _errors = new List<string>();

        if (string.IsNullOrWhiteSpace(Username))
        {
            _errors.Add("Username cannot be empty.");
        }

        if (string.IsNullOrWhiteSpace(Password))
        {
            _errors.Add("Password cannot be empty.");
        }

        return _errors.Any() ? new Result<bool>(ErrorType.BadRequest, _errors) : new Result<bool>(true);
    }
}
